% !TEX root = main.tex
\section{GenericMonitoringTool jako wynik refaktoryzacji kodu}
Wynikiem refaktoryzacji modułu AthenaMonitoring i przykładowych algorytmów monitorowanych jest klasa GenericMonitoringTool.
Agreguje ona funkcjonalności zidentyfikowane jako kluczowe dla monitoringu, czyli możliwość deklaracji histogramów oraz wypełnianie ich zmiennymi monitorowanymi z kodu algorytmów.
Jednak w przeciwieństwie do pierwotnej implementacji, dostarcza ona kilka poziomów abstrakcji, umożliwiających centralizację połączenia pomiędzy tymi dwiema warstwami.
Refaktoryzacja wprowadziła wiele nowych rozwiązań, które sprawiły, że kod stał się bardziej elastyczny i łatwiejszy w użyciu.

Największym zyskiem z nowej implementacji jest oddzielenie kodu zarządzającego cyklem życia obiektów ROOT od kodu algorytmów. 
Pozwoliło to zredukować ich objętość i umożliwiło osobom implementującym algorytmy skupienie się na ich głównym zadaniu, zamiast na obsłudze histogramów.
Dodatkowo sprawia to, że kod monitoringu stał się scentralizowany, dzięki czemu możliwe stały się aktualizacje ROOT, bez potrzeby modyfikowania już istniejących algorytmów.

Po refaktoryzacji możliwe stało się rozwiązanie problemu scalania histogramów.
Dzięki temu, że w nowym rozwiązaniu istnieje centralny punkt w którym obsługiwane są histogramy, łatwe stało się dodanie zabezpieczeń dla wywołań wielowątkowych w postaci użycia `mutex`ów.
Zapewniają one spójność danych wpisywanych do obiektów ROOT, a mają przy tym bardzo mały narzut czasowy.

Wdrożone warstwy abstrakcji, umożliwiły łatwiejsze dodawanie nowych funkcjonalności, które mogą realizować bardzo złożone scenariusze wypełniania histogramów.
Dobrym przykładem jest tu klasa LumiblockHistogramProvider, która realizuje funkcjonalność podziału danych na postawie kontekstu w jakim zostały one wygenerowane. 
Zaimplementowanie jej funkcjonalności w kodzie algorytmu byłoby bardzo trudnym zadaniem. 

Dodatkowym zyskiem z takiego rozdzielenia odpowiedzialności, było umożliwienie tworzenia testów jednostkowych. 
Znacznie podniosło to jakość kodu pisanego na potrzeby GenericMonitoringTool.
Umożliwiło to również wcześniejsze wykrywanie problemów w programie, bez potrzeby uruchomiania algorytmów. 
Znacznie przyśpieszyło to proces tworzenia nowego kodu.

\subsection{Wydajność wielowątkowa}

\begin{figure}[!ht]
\centering
\includegraphics[width=1\textwidth]{img/avg_run_time.png}
\caption{
0 - czas losowania 40M danych; 
1 - bezpośrednie wypełnianie histogramu z algorytmu;
2 - zmienna monitorowana bez synchronizacji wątków;
3 - zmienna monitorowana z synchronizacją wątków;
0,1 - jeden wątek;
0,2 - 800 wątków;
0,3 - 800 wątków + mutex;
1,1 - jeden wątek;
1,2 - 800 wątków, kompletność danych 5,15\%;
1,3 - 800 wątków + mutex;
2,1 - jeden wątek, histogram utworzony raz;
2,2 - jeden wątek, histogram tworzony za każdym razem;
2,3 - 800 wątków, histogram utworzony raz, kompletność danych 9,6\%;
2,4 - 800 wątków, histogram tworzony za każdym razem, kompletność danych 4,48\%;
2,5 - 800 wątków + mutex, histogram utworzony raz;
2,6 - 800 wątków + mutex, histogram tworzony za każdym razem;
3,1 - jeden wątek, histogram utworzony raz;
3,2 - jeden wątek, histogram tworzony za każdym razem;
3,3 - 800 wątków, histogram utworzony raz;
3,4 - 800 wątków, histogram tworzony za każdym razem;
}
\label{fig:athena:avgRunTime}
\end{figure}

Podczas implementacji zabezpieczeń przetwarzania wielowątkowego dla GenericMonitoringTool, bardzo ważne było sprawdzenie jak duży jest narzut na synchronizacje wątków. 
Przetestowane zostało kilka rozwiązań, w rezultacie najlepsze okazało się zastosowanie `mutex`'a z biblioteki standardowej C++ wewnątrz zmiennej monitorowanej. 
\figref{fig:athena:avgRunTime} prezentuje wyniki tych testów. 
W ich przypadku, czas działania algorytmu jest pomijalnie mały, gdyż jest w nich losowana pojedyncza wartość liczbowa.
W rzeczywistym użyciu spodziewane jest, że czas wykonywania algorytmu będzie dużo większy od czasu potrzebnego na obsługę sekcji krytycznej. 
Najbardziej reprezentatywne na tym wykresie są przypadki 1,3 oraz 3,3.

1,3 jest wynikiem działania kodu, który wykorzystuje mechanizmy dostępne przed refaktoryzacją.
Użytkownik samemu obsługuje synchronizacje z wykorzystaniem mutex'a dla 800 wątków i wypełnia histogram odwołując się bezpośrednio do obiektów frameworka ROOT.

3,3 jest wynikiem działania kodu wykorzystującego zmienną monitorowaną, która w sposób niewidoczny dla użytkownika troszczy się o synchronizację i wypełnienie histogramów ROOT. 

Różnica w czasie wykonania na korzyść zmiennej monitorowanej spowodowana jest optymalizacjami dokonanymi przez kompilator.

\subsection{Testy jednostkowe}
\begin{itemize}
\item opis struktury testów
\item opisać makra
\item opisać rejestracje testów
\item co dają mocki
\item kod~\cite{histogram-factory-test-suite}
\end{itemize}